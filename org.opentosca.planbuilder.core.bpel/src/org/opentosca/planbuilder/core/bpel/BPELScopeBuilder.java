package org.opentosca.planbuilder.core.bpel;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.opentosca.planbuilder.core.bpel.helpers.TOSCAManagementInfrastructureNodeTemplate;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderPlugin;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderPrePhaseDAPlugin;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderPrePhaseIAPlugin;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderProvPhaseOperationPlugin;
import org.opentosca.planbuilder.core.plugins.registry.PluginRegistry;
import org.opentosca.planbuilder.model.tosca.AbstractDeploymentArtifact;
import org.opentosca.planbuilder.model.tosca.AbstractImplementationArtifact;
import org.opentosca.planbuilder.model.tosca.AbstractInterface;
import org.opentosca.planbuilder.model.tosca.AbstractNodeTemplate;
import org.opentosca.planbuilder.model.tosca.AbstractNodeTypeImplementation;
import org.opentosca.planbuilder.model.tosca.AbstractOperation;
import org.opentosca.planbuilder.model.tosca.AbstractRelationshipTemplate;
import org.opentosca.planbuilder.model.tosca.AbstractRelationshipTypeImplementation;
import org.opentosca.planbuilder.model.utils.ModelUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * This Class represents the low-level algorithm for the concept in <a href=
 * "http://www2.informatik.uni-stuttgart.de/cgi-bin/NCSTRL/NCSTRL_view.pl?id=BCLR-0043&mod=0&engl=1&inst=FAK"
 * >Konzept und Implementierung eine Java-Komponente zur Generierung von WS-BPEL 2.0 BuildPlans fuer
 * OpenTOSCA</a>. This includes selecting a implementation (NodeTypeImplementation,Relationship..)
 * where all artifacts (IA, DA) and the operations of the template (Node and Relation) can be used
 * for calling a chain/list/.. of TOSCA operations. All complete possibilities of calls based on the
 * selected Node Type Implementation are hold inside a OperationChain Object. And can be selected to
 * be generated by the determined operations and handling plugins.
 *
 * </p>
 * Copyright 2017 IAAS University of Stuttgart <br>
 * <br>
 *
 * @author Kalman Kepes - kepeskn@studi.informatik.uni-stuttgart.de
 *
 */
public class BPELScopeBuilder {

    final static Logger LOG = LoggerFactory.getLogger(BPELScopeBuilder.class);

    private static PluginRegistry pluginRegistry = new PluginRegistry();

    /**
     * <p>
     * Filters IA and DA Candidates inside the given ProvisioningChain. Filtering means if there are IA
     * and DACandidates which don't operate on the same Template Implementation they are deleted.
     * </p>
     *
     * @param chain a ProvisioningChain to filter
     */
    private static void filterIncompatibleIADACandidates(final OperationChain chain) {
        final Map<IANodeTypeImplCandidate, DANodeTypeImplCandidate> compatibleCandidates = new HashMap<>();
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            for (final DANodeTypeImplCandidate daCandidate : chain.daCandidates) {
                if (iaCandidate.nodeImpl.getName().equals(daCandidate.impl.getName())) {
                    compatibleCandidates.put(iaCandidate, daCandidate);
                }
            }
        }
        chain.daCandidates = new ArrayList<>();
        chain.iaCandidates = new ArrayList<>();

        for (final IANodeTypeImplCandidate key : compatibleCandidates.keySet()) {
            chain.iaCandidates.add(key);
            chain.daCandidates.add(compatibleCandidates.get(key));
        }
    }

    /**
     * Creates a ProvisioningChain for the given RelationshipTemplate.
     *
     * @param relationshipTemplate an AbstractRelationshipTemplate which should be provisioned
     * @param forSource determines whether provisioning is handle on the SourceInterface (set to true)
     *        or TargetInterface
     * @return a ProvisioningChain with complete provisioning Candidates
     */
    public static OperationChain createOperationChain(final AbstractRelationshipTemplate relationshipTemplate,
                    final boolean forSource) {
        // get implementations
        final List<AbstractRelationshipTypeImplementation> relationshipTypeImpls = relationshipTemplate.getImplementations();

        if (relationshipTypeImpls.isEmpty()) {
            return null;
        }

        // init chain
        final OperationChain chain = new OperationChain(relationshipTemplate);

        // calculate infraNodes
        final List<AbstractNodeTemplate> infraNodes = new ArrayList<>();

        ModelUtils.getInfrastructureNodes(relationshipTemplate, infraNodes, forSource);

        // check for IA Plugins
        final List<IPlanBuilderPrePhaseIAPlugin<?>> iaPlugins = BPELScopeBuilder.pluginRegistry.getIaPlugins();

        BPELScopeBuilder.calculateBestImplementationRelationIACandidates(relationshipTypeImpls, iaPlugins, infraNodes,
            chain, forSource);

        // check for prov plugins
        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins = BPELScopeBuilder.pluginRegistry.getProvPlugins();

        BPELScopeBuilder.calculateProvPlugins(chain, provPlugins);

        BPELScopeBuilder.filterIADACandidatesRelations(chain);

        BPELScopeBuilder.reorderProvCandidates(chain);

        return chain;
    }

    /**
     * Creates a complete ProvisioningChain for the given NodeTemplate
     *
     * @param nodeTemplate an AbstractNodeTemplate to create a ProvisioningChain for
     * @return a complete ProvisioningChain
     */
    public static OperationChain createOperationCall(final AbstractNodeTemplate nodeTemplate,
                    final String interfaceName, final String operationName) {
        // get nodetype implementations
        final List<AbstractNodeTypeImplementation> nodeTypeImpls = nodeTemplate.getImplementations();

        if (nodeTypeImpls.isEmpty()) {
            BPELScopeBuilder.LOG.warn(
                "No implementations available for NodeTemplate {} , can't generate Provisioning logic",
                nodeTemplate.getId());
            return null;
        }

        final OperationChain chain = new OperationChain(nodeTemplate);

        // calculate infrastructure nodes
        final List<AbstractNodeTemplate> infraNodes = new ArrayList<>();
        ModelUtils.getInfrastructureNodes(nodeTemplate, infraNodes);

        // we'll add here a dummy infra node, representing the management
        // infrastructure of the tosca engine (WAR IA's implementing tosca
        // operation,..)
        infraNodes.add(new TOSCAManagementInfrastructureNodeTemplate());

        // check for IA Plugins
        final List<IPlanBuilderPrePhaseIAPlugin<?>> iaPlugins = BPELScopeBuilder.pluginRegistry.getIaPlugins();

        BPELScopeBuilder.LOG.debug("Calculating best IA candidates for nodeTemplate {} ", nodeTemplate.getId());
        // calculate nodeImpl candidates where all IAs of each can be
        // provisioned
        BPELScopeBuilder.calculateBestImplementationIACandidates(nodeTypeImpls, iaPlugins, infraNodes, chain,
            interfaceName, operationName);
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            final int length = iaCandidate.ias.size();
            for (int i = 0; i < length; i++) {
                final AbstractImplementationArtifact ia = iaCandidate.ias.get(i);
                final AbstractNodeTemplate infraNode = iaCandidate.infraNodes.get(i);
                final IPlanBuilderPlugin plugin = iaCandidate.plugins.get(i);
                BPELScopeBuilder.LOG.debug("Found IA {} for deployment on the InfraNode {} with the Plugin {}",
                    ia.getName(), infraNode.getId(), plugin.getID());
            }
        }

        // check for prov plugins
        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins = BPELScopeBuilder.pluginRegistry.getProvPlugins();

        // search for prov plugins according to the chosen IA provisionings in
        // the chain
        BPELScopeBuilder.calculateProvPlugins(chain, provPlugins, interfaceName, operationName);

        // filter ia and da candidates where the operations can't be executed
        BPELScopeBuilder.filterIADACandidates(chain);

        // order provisioning candidates
        BPELScopeBuilder.reorderProvCandidates(chain);

        // TODO consistency plugins

        // select provisioning
        BPELScopeBuilder.selectProvisioning(chain);

        return chain;
    }

    /**
     * Creates a complete ProvisioningChain for the given NodeTemplate
     *
     * @param nodeTemplate an AbstractNodeTemplate to create a ProvisioningChain for
     * @return a complete ProvisioningChain
     */
    public static OperationChain createOperationChain(final AbstractNodeTemplate nodeTemplate) {
        // get nodetype implementations
        final List<AbstractNodeTypeImplementation> nodeTypeImpls = nodeTemplate.getImplementations();

        if (nodeTypeImpls.isEmpty()) {
            BPELScopeBuilder.LOG.warn(
                "No implementations available for NodeTemplate {} , can't generate Provisioning logic",
                nodeTemplate.getId());
            return null;
        }

        final OperationChain chain = new OperationChain(nodeTemplate);

        // calculate infrastructure nodes
        final List<AbstractNodeTemplate> infraNodes = new ArrayList<>();
        ModelUtils.getInfrastructureNodes(nodeTemplate, infraNodes);

        // we'll add here a dummy infra node, representing the management
        // infrastructure of the tosca engine (WAR IA's implementing tosca
        // operation,..)
        infraNodes.add(new TOSCAManagementInfrastructureNodeTemplate());

        // check for IA Plugins
        final List<IPlanBuilderPrePhaseIAPlugin<?>> iaPlugins = BPELScopeBuilder.pluginRegistry.getIaPlugins();

        BPELScopeBuilder.LOG.debug("Calculating best IA candidates for nodeTemplate {} ", nodeTemplate.getId());
        // calculate nodeImpl candidates where all IAs of each can be
        // provisioned
        BPELScopeBuilder.calculateBestImplementationIACandidates(nodeTypeImpls, iaPlugins, infraNodes, chain);
        for (final IANodeTypeImplCandidate wrapper : chain.iaCandidates) {
            final int length = wrapper.ias.size();
            for (int i = 0; i < length; i++) {
                final AbstractImplementationArtifact ia = wrapper.ias.get(i);
                final AbstractNodeTemplate infraNode = wrapper.infraNodes.get(i);
                final IPlanBuilderPlugin plugin = wrapper.plugins.get(i);
                BPELScopeBuilder.LOG.debug("Found IA {} for deployment on the InfraNode {} with the Plugin {}",
                    ia.getName(), infraNode.getId(), plugin.getID());
            }
        }

        // check for DA Plugins
        final List<IPlanBuilderPrePhaseDAPlugin<?>> daPlugins = BPELScopeBuilder.pluginRegistry.getDaPlugins();

        // calculate nodeImpl candidates where all DAs of each can be
        // provisioned
        BPELScopeBuilder.calculateBestImplementationDACandidates(nodeTemplate, nodeTypeImpls, daPlugins, infraNodes,
            chain);
        for (final DANodeTypeImplCandidate wrapper : chain.daCandidates) {
            final int length = wrapper.das.size();
            for (int i = 0; i < length; i++) {
                final AbstractDeploymentArtifact da = wrapper.das.get(i);
                final AbstractNodeTemplate infraNode = wrapper.infraNodes.get(i);
                final IPlanBuilderPlugin plugin = wrapper.plugins.get(i);
                BPELScopeBuilder.LOG.debug("Found DA {} for deployment on the InfraNode {} with the Plugin {}",
                    da.getName(), infraNode.getId(), plugin.getID());
            }
        }

        // filter for nodeTypeImpl Candidates where both DAs and IAs can
        // be provisioned
        BPELScopeBuilder.filterIncompatibleIADACandidates(chain);

        // check for prov plugins
        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins = BPELScopeBuilder.pluginRegistry.getProvPlugins();

        // search for prov plugins according to the chosen IA provisionings in
        // the chain
        BPELScopeBuilder.calculateProvPlugins(chain, provPlugins);

        // filter ia and da candidates where the operations can't be executed
        BPELScopeBuilder.filterIADACandidates(chain);

        // order provisioning candidates
        BPELScopeBuilder.reorderProvCandidates(chain);

        // TODO consistency plugins

        // select provisioning
        BPELScopeBuilder.selectProvisioning(chain);

        return chain;
    }

    /**
     * Reorders the IA/ProvCandidates inside the given ProvisioningChain, so that a correct order is
     * enforced
     *
     * @param chain a ProvisioningChain
     */
    private static void reorderProvCandidates(final OperationChain chain) {
        // ia candidates and da candidates in the chains are already ordered
        // accordingly
        final List<OperationNodeTypeImplCandidate> reorderedList = new ArrayList<>();
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            final int iaCandidateSize = iaCandidate.ias.size();
            for (final OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
                int count = 0;
                for (final AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
                    for (final AbstractImplementationArtifact provCandidateIa : provCandidate.ias) {
                        if (iaCandidateIa.equals(provCandidateIa)) {
                            count++;
                        }
                    }
                }
                if (count == iaCandidateSize) {
                    reorderedList.add(provCandidate);
                }
            }
        }

        chain.provCandidates = reorderedList;

    }

    /**
     * Filters IA and ProvCandidates which aren't generated from the same Template Implementation
     *
     * @param chain a ProvisioningChain
     */
    private static void filterIADACandidatesRelations(final OperationChain chain) {
        if (chain.provCandidates.size() != chain.iaCandidates.size()) {
            final List<IANodeTypeImplCandidate> iaCandidatesToRemove = new ArrayList<>();
            final Set<OperationNodeTypeImplCandidate> provCandidatesWithMatch = new HashSet<>();
            for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
                final int iaCandidateSize = iaCandidate.ias.size();
                OperationNodeTypeImplCandidate match = null;
                for (final OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
                    int count = 0;
                    for (final AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
                        for (final AbstractImplementationArtifact procCandidateIa : provCandidate.ias) {
                            if (iaCandidateIa.equals(procCandidateIa)) {
                                count++;
                            }
                        }
                    }
                    if (count == iaCandidateSize) {
                        match = provCandidate;
                    }
                }
                if (match == null && !chain.provCandidates.isEmpty()) {
                    iaCandidatesToRemove.add(iaCandidate);
                } else {
                    if (match != null) {
                        provCandidatesWithMatch.add(match);
                    }
                }
            }
            if (!iaCandidatesToRemove.isEmpty()) {
                // we need to remove ia and da candidates accordingly, because
                // we didn't found matchin operation candidates for them
                for (final IANodeTypeImplCandidate iaCandidateToRemove : iaCandidatesToRemove) {
                    final int index = chain.iaCandidates.indexOf(iaCandidateToRemove);
                    chain.iaCandidates.remove(index);
                }
            }

            if (!provCandidatesWithMatch.isEmpty()) {
                // remove all prov candidates which weren't matched to some ia
                // candidate
                chain.provCandidates = new ArrayList<>();
                for (final OperationNodeTypeImplCandidate matchedCandidate : provCandidatesWithMatch) {
                    chain.provCandidates.add(matchedCandidate);
                }
            }
        }
    }

    /**
     * Filters DA/IA Candidates where no OperationCandidates could be found
     *
     * @param chain a ProvisioningChain
     */
    private static void filterIADACandidates(final OperationChain chain) {
        if (chain.provCandidates.size() != chain.iaCandidates.size()) {
            // search for ia/da-Candidates where no operation candidate could be
            // found
            final List<IANodeTypeImplCandidate> iaCandidatesToRemove = new ArrayList<>();
            final Set<OperationNodeTypeImplCandidate> provCandidatesWithMatch = new HashSet<>();
            for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
                final int iaCandidateSize = iaCandidate.ias.size();
                OperationNodeTypeImplCandidate match = null;
                for (final OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
                    int count = 0;
                    for (final AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
                        for (final AbstractImplementationArtifact provCandidateIa : provCandidate.ias) {
                            if (iaCandidateIa.equals(provCandidateIa)) {
                                count++;
                            }
                        }
                    }
                    if (count == iaCandidateSize) {
                        match = provCandidate;
                    }
                }
                if (match == null && !chain.provCandidates.isEmpty()) {
                    iaCandidatesToRemove.add(iaCandidate);
                } else {
                    if (match != null) {
                        provCandidatesWithMatch.add(match);
                    }
                }
            }

            if (!iaCandidatesToRemove.isEmpty()) {
                // we need to remove ia and da candidates accordingly, because
                // we didn't found matchin operation candidates for them
                for (final IANodeTypeImplCandidate iaCandidateToRemove : iaCandidatesToRemove) {
                    final int index = chain.iaCandidates.indexOf(iaCandidateToRemove);
                    chain.iaCandidates.remove(index);
                    chain.daCandidates.remove(index);
                }
            }

            if (!provCandidatesWithMatch.isEmpty()) {
                // remove all prov candidates which weren't matched to some ia
                // candidate
                chain.provCandidates = new ArrayList<>();
                for (final OperationNodeTypeImplCandidate matchedCandidate : provCandidatesWithMatch) {
                    chain.provCandidates.add(matchedCandidate);
                }
            }
        }
    }

    private static void selectProvisioning(final OperationChain chain) {
        // TODO just select the first ia candidate, da candidate and prov
        // candidate for now
        // Selection should determine a minimal provisioning. Minimal=
        // min{|IACandidates| + |DACandidates| +|ProvPhaseOperations|}
    }

    /**
     * Calculates which Provisioning can be used for Provisioining according to the given
     * IA/DACandidates inside the given ProvisioningChain
     *
     * @param chain a ProvisioningChain with set DA/IACandidates
     * @param provPlugins a List of ProvPhaseOperationPlugins
     */
    private static void calculateProvPlugins(final OperationChain chain,
                    final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins, final String interfaceName,
                    final String operationName) {
        final List<OperationNodeTypeImplCandidate> candidates = new ArrayList<>();
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            final OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
            for (final AbstractImplementationArtifact ia : iaCandidate.ias) {
                if (!ia.getInterfaceName().trim().equals(interfaceName.trim())) {
                    continue;
                }
                if (ia.getOperationName() != null && !ia.getOperationName().trim().equals(operationName.trim())) {
                    continue;
                }
                for (final IPlanBuilderProvPhaseOperationPlugin<?> plugin : provPlugins) {
                    if (chain.nodeTemplate != null) {
                        if (plugin.canHandle(ia.getArtifactType())
                            && BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia) != null) {

                            provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia), ia, plugin);
                        }
                    } else {
                        if (plugin.canHandle(ia.getArtifactType())
                            && BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia) != null) {
                            provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia), ia,
                                plugin);
                        }
                    }
                }
            }
            if (chain.nodeTemplate != null) {
                if (provCandidate.isValid(chain.nodeTemplate, interfaceName, operationName)) {
                    candidates.add(provCandidate);
                }
            } else {
                if (provCandidate.isValid(chain.relationshipTemplate)) {
                    candidates.add(provCandidate);
                }
            }

        }
        chain.provCandidates = candidates;
    }

    /**
     * Calculates which Provisioning can be used for Provisioining according to the given
     * IA/DACandidates inside the given ProvisioningChain
     *
     * @param chain a ProvisioningChain with set DA/IACandidates
     * @param provPlugins a List of ProvPhaseOperationPlugins
     */
    private static void calculateProvPlugins(final OperationChain chain,
                    final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins) {
        final List<OperationNodeTypeImplCandidate> candidates = new ArrayList<>();
        for (final IANodeTypeImplCandidate candidate : chain.iaCandidates) {
            final OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
            for (final AbstractImplementationArtifact ia : candidate.ias) {
                for (final IPlanBuilderProvPhaseOperationPlugin plugin : provPlugins) {
                    if (chain.nodeTemplate != null) {
                        if (plugin.canHandle(ia.getArtifactType())
                            && BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia) != null) {

                            provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia), ia, plugin);
                        }
                    } else {
                        if (plugin.canHandle(ia.getArtifactType())
                            && BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia) != null) {
                            provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia), ia,
                                plugin);
                        }
                    }
                }
            }
            if (chain.nodeTemplate != null) {
                if (provCandidate.isValid(chain.nodeTemplate)) {
                    candidates.add(provCandidate);
                }
            } else {
                if (provCandidate.isValid(chain.relationshipTemplate)) {
                    candidates.add(provCandidate);
                }
            }

        }
        chain.provCandidates = candidates;
    }

    /**
     * Returns the Operation which is implemented by the given IA
     *
     * @param nodeTemplate an AbstractNodeTemplate
     * @param ia an AbstractImplementationArtifact
     * @return AbstractOperation of the NodeTemplate if the given IA implements it, else null
     */
    private static AbstractOperation getOperationForIa(final AbstractNodeTemplate nodeTemplate,
                    final AbstractImplementationArtifact ia) {

        if (ia.getInterfaceName() != null & ia.getOperationName() == null) {
            return new InterfaceDummy(nodeTemplate, ia);
        }

        for (final AbstractInterface iface : nodeTemplate.getType().getInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(ia.getOperationName())) {
                    return op;
                }
            }
        }
        return null;
    }

    /**
     * Returns the Operation which is implemented by the given IA
     *
     * @param relationshipTemplate an AbstractRelationshipTemplate
     * @param ia an AbstractImplementationArtifact
     * @return AbstractOperation of the RelationshipTemplate if the given IA implements it, else null
     */
    private static AbstractOperation getOperationForIa(final AbstractRelationshipTemplate relationshipTemplate,
                    final AbstractImplementationArtifact ia) {
        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getSourceInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(ia.getOperationName())) {
                    return op;
                }
            }
        }

        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getTargetInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(ia.getOperationName())) {
                    return op;
                }
            }
        }
        return null;
    }

    /**
     * Calculates correct mappings of the given NodeTypeImplementations, PrePhaseDAPlugins and
     * InfrastructureNodes for the given ProvisioningChain
     *
     * @param impls a List of NodeTypeImplementations
     * @param plugins a List of PrePhaseDAPlugins
     * @param infraNodes a List of InfrastructureNode of the NodeTemplate the NodeTypeImplementations
     *        belong to
     * @param chain a ProvisioningChain where the candidates are added to
     */
    private static void calculateBestImplementationDACandidates(final AbstractNodeTemplate nodeTemplate,
                    final List<AbstractNodeTypeImplementation> impls,
                    final List<IPlanBuilderPrePhaseDAPlugin<?>> plugins, final List<AbstractNodeTemplate> infraNodes,
                    final OperationChain chain) {
        final List<DANodeTypeImplCandidate> candidates = new ArrayList<>();

        for (final AbstractNodeTypeImplementation impl : impls) {
            BPELScopeBuilder.LOG.debug("Checking DAs of NodeTypeImpl {} and NodeTemplate {}", impl.getName(),
                nodeTemplate.getId());
            final DANodeTypeImplCandidate candidate = new DANodeTypeImplCandidate(nodeTemplate, impl);

            final List<AbstractDeploymentArtifact> effectiveDAs = BPELScopeBuilder.calculateEffectiveDAs(nodeTemplate,
                impl);

            for (final AbstractDeploymentArtifact da : effectiveDAs) {
                BPELScopeBuilder.LOG.debug("Checking whether DA {} can be deployed", da.getName());
                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    BPELScopeBuilder.LOG.debug("Checking if DA {} can be deployed on InfraNode {}", da.getName(),
                        infraNode.getId());
                    for (final IPlanBuilderPrePhaseDAPlugin plugin : plugins) {
                        BPELScopeBuilder.LOG.debug("Checking with Plugin {}", plugin.getID());
                        if (plugin.canHandle(da, infraNode.getType())) {
                            BPELScopeBuilder.LOG.debug("Adding Plugin, can handle DA on InfraNode");
                            candidate.add(da, infraNode, plugin);
                        }
                    }
                }
            }
            if (candidate.isValid()) {
                BPELScopeBuilder.LOG.debug("Generated Candidate was valid, adding to all Candidates");
                candidates.add(candidate);
            } else {
                BPELScopeBuilder.LOG.debug("Generated Candidate was invalid, don't add to all Candidates");
            }
        }
        chain.daCandidates = candidates;
    }

    /**
     * Searches for NodeTypeImplementations where all IA's can be provisioned by some plugin in the
     * system.
     *
     * @param impls all implementations of single nodetype
     * @param plugins all plugins possibly capable of working with the ia's contained in a
     *        nodetypeImplementation
     * @param infraNodes all infrastructure nodes of the nodetemplate the nodetypeimplementations
     *        originate from
     * @return a list of Wrapper class Object which contain information of which ia is provisioned on
     *         which infrastructure by which plugin
     */
    private static void calculateBestImplementationIACandidates(final List<AbstractNodeTypeImplementation> impls,
                    final List<IPlanBuilderPrePhaseIAPlugin<?>> plugins, final List<AbstractNodeTemplate> infraNodes,
                    final OperationChain chain, final String interfaceName, final String operationName) {

        final List<IANodeTypeImplCandidate> candidates = new ArrayList<>();
        // cycle through all implementations
        for (final AbstractNodeTypeImplementation impl : impls) {
            final IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
            // match the ias of the implementation with the infrastructure nodes
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                if (!ia.getInterfaceName().trim().equals(interfaceName.trim())) {
                    continue;
                }
                if (ia.getOperationName() != null && !ia.getOperationName().trim().equals(operationName.trim())) {
                    continue;
                }

                BPELScopeBuilder.LOG.debug("Checking whether IA {} can be deployed on a specific Infrastructure Node",
                    ia.getName());
                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    // check if any plugin can handle installing the ia on the
                    // infraNode
                    for (final IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
                        if (plugin.canHandle(ia, infraNode.getType())) {
                            candidate.add(ia, infraNode, plugin);
                        }
                    }
                }
            }
            // check if all ias of the implementation can be provisioned
            if (candidate.isValid(interfaceName, operationName)) {
                candidates.add(candidate);
                BPELScopeBuilder.LOG.debug("IA Candidate is valid, adding to candidate list");
            } else {
                BPELScopeBuilder.LOG.debug("IA Candidate is invalid, discarding candidate");
            }
        }
        chain.iaCandidates = candidates;
    }

    /**
     * Searches for NodeTypeImplementations where all IA's can be provisioned by some plugin in the
     * system.
     *
     * @param impls all implementations of single nodetype
     * @param plugins all plugins possibly capable of working with the ia's contained in a
     *        nodetypeImplementation
     * @param infraNodes all infrastructure nodes of the nodetemplate the nodetypeimplementations
     *        originate from
     * @return a list of Wrapper class Object which contain information of which ia is provisioned on
     *         which infrastructure by which plugin
     */
    private static void calculateBestImplementationIACandidates(final List<AbstractNodeTypeImplementation> impls,
                    final List<IPlanBuilderPrePhaseIAPlugin<?>> plugins, final List<AbstractNodeTemplate> infraNodes,
                    final OperationChain chain) {

        final List<IANodeTypeImplCandidate> candidates = new ArrayList<>();
        // cycle through all implementations
        for (final AbstractNodeTypeImplementation impl : impls) {
            final IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
            // match the ias of the implementation with the infrastructure nodes
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                BPELScopeBuilder.LOG.debug("Checking whether IA {} can be deployed on a specific Infrastructure Node",
                    ia.getName());
                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    // check if any plugin can handle installing the ia on the
                    // infraNode
                    for (final IPlanBuilderPrePhaseIAPlugin<?> plugin : plugins) {
                        if (plugin.canHandle(ia, infraNode.getType())) {
                            candidate.add(ia, infraNode, plugin);
                        }
                    }
                }
            }
            // check if all ias of the implementation can be provisioned
            if (candidate.isValid()) {
                candidates.add(candidate);
                BPELScopeBuilder.LOG.debug("IA Candidate is valid, adding to candidate list");
            } else {
                BPELScopeBuilder.LOG.debug("IA Candidate is invalid, discarding candidate");
            }
        }
        chain.iaCandidates = candidates;
    }

    /**
     * Checks whether the IA implements a SourceInterfaceOperation
     *
     * @param ia the IA to check with
     * @param relationshipTemplate the RelationshipTemplate to check with
     * @return true if the IA implements a Operation inside a SourceInterface of the
     *         RelationshipTemplate
     */
    private static boolean checkIfIaImplementsSrcIface(final AbstractImplementationArtifact ia,
                    final AbstractRelationshipTemplate relationshipTemplate) {

        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getSourceInterfaces()) {
            if (iface.getName().equals(ia.getInterfaceName())) {
                for (final AbstractOperation op : iface.getOperations()) {
                    if (op.getName().equals(ia.getOperationName())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Calculates correct mappings for the given RelationshipTypeImplementations with the given Plugins
     * and InfraNodes
     *
     * @param impls a List of RelationshipTypeImplementation
     * @param plugins a List of PrePhaseIAPlugins
     * @param infraNodes a List of InfrastructureNodes which belong to the RelationshipTemplate the
     *        given Implementation belong to
     * @param chain a ProvisioningChain to save the results
     * @param forSource whether the calculation is done for the SourceInterface or for the
     *        TargetInterface
     */
    private static void calculateBestImplementationRelationIACandidates(
                    final List<AbstractRelationshipTypeImplementation> impls,
                    final List<IPlanBuilderPrePhaseIAPlugin<?>> plugins, final List<AbstractNodeTemplate> infraNodes,
                    final OperationChain chain, final boolean forSource) {
        final List<IANodeTypeImplCandidate> candidates = new ArrayList<>();
        for (final AbstractRelationshipTypeImplementation impl : impls) {
            final IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                if (forSource) {
                    // check if ia implements source interfaces
                    if (!BPELScopeBuilder.checkIfIaImplementsSrcIface(ia, chain.relationshipTemplate)) {
                        continue;
                    }
                } else {
                    if (BPELScopeBuilder.checkIfIaImplementsSrcIface(ia, chain.relationshipTemplate)) {
                        continue;
                    }
                }

                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    for (final IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
                        if (plugin.canHandle(ia, infraNode.getType())) {
                            candidate.add(ia, infraNode, plugin);
                        }
                    }
                }
            }
            if (candidate.isValid()) {
                candidates.add(candidate);
            }
        }
        chain.iaCandidates = candidates;

    }

    /**
     * Calculates a list of DA's containing an effective set of DA combining the DA's from the given
     * NodeImplementation and NodeTemplates according to the TOSCA specification.
     *
     * @param nodeTemplate the NodeTemplate the NodeImplementations belongs to
     * @param nodeImpl a NodeTypeImplementation for the given NodeTemplate
     * @return a possibly empty list of AbstractDeploymentArtifacts
     */
    static List<AbstractDeploymentArtifact> calculateEffectiveDAs(final AbstractNodeTemplate nodeTemplate,
                    final AbstractNodeTypeImplementation nodeImpl) {
        final List<AbstractDeploymentArtifact> effectiveDAs = new ArrayList<>();

        final List<AbstractDeploymentArtifact> nodeImplDAs = nodeImpl.getDeploymentArtifacts();
        final List<AbstractDeploymentArtifact> nodeTemplateDAs = nodeTemplate.getDeploymentArtifacts();

        for (final AbstractDeploymentArtifact templateDa : nodeTemplateDAs) {
            boolean overridesDA = false;
            int daIndex = -1;
            for (int i = 0; i < nodeImplDAs.size(); i++) {
                final AbstractDeploymentArtifact nodeImplDa = nodeImplDAs.get(i);

                if (nodeImplDa.getName().equals(templateDa.getName())
                    & nodeImplDa.getArtifactType().equals(nodeImplDa.getArtifactType())) {
                    overridesDA = true;
                    daIndex = i;
                }
            }

            if (overridesDA) {
                nodeImplDAs.remove(daIndex);
            }
        }

        effectiveDAs.addAll(nodeTemplateDAs);
        effectiveDAs.addAll(nodeImplDAs);

        return effectiveDAs;
    }
}
