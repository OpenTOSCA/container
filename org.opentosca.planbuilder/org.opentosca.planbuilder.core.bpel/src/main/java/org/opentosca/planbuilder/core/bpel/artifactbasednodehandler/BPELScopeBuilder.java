package org.opentosca.planbuilder.core.bpel.artifactbasednodehandler;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.inject.Inject;

import org.opentosca.planbuilder.core.bpel.tosca.handlers.TOSCAManagementInfrastructureNodeTemplate;
import org.opentosca.planbuilder.core.plugins.artifactbased.IPlanBuilderPrePhaseDAPlugin;
import org.opentosca.planbuilder.core.plugins.artifactbased.IPlanBuilderPrePhaseIAPlugin;
import org.opentosca.planbuilder.core.plugins.artifactbased.IPlanBuilderProvPhaseOperationPlugin;
import org.opentosca.planbuilder.core.plugins.registry.PluginRegistry;
import org.opentosca.planbuilder.core.plugins.typebased.IPlanBuilderPlugin;
import org.opentosca.planbuilder.model.tosca.AbstractDeploymentArtifact;
import org.opentosca.planbuilder.model.tosca.AbstractImplementationArtifact;
import org.opentosca.planbuilder.model.tosca.AbstractInterface;
import org.opentosca.planbuilder.model.tosca.AbstractNodeTemplate;
import org.opentosca.planbuilder.model.tosca.AbstractNodeTypeImplementation;
import org.opentosca.planbuilder.model.tosca.AbstractOperation;
import org.opentosca.planbuilder.model.tosca.AbstractRelationshipTemplate;
import org.opentosca.planbuilder.model.tosca.AbstractRelationshipTypeImplementation;
import org.opentosca.planbuilder.model.utils.ModelUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * <p>
 * This Class represents the low-level algorithm for the concept in <a href= "http://www2.informatik.uni-stuttgart.de/cgi-bin/NCSTRL/NCSTRL_view.pl?id=BCLR-0043&mod=0&engl=1&inst=FAK"
 * >Konzept und Implementierung eine Java-Komponente zur Generierung von WS-BPEL 2.0 BuildPlans fuer OpenTOSCA</a>. This
 * includes selecting a implementation (NodeTypeImplementation,Relationship..) where all artifacts (IA, DA) and the
 * operations of the template (Node and Relation) can be used for calling a chain/list/.. of TOSCA operations. All
 * complete possibilities of calls based on the selected Node Type Implementation are hold inside a OperationChain
 * Object. And can be selected to be generated by the determined operations and handling plugins.
 *
 * </p>
 * Copyright 2017 IAAS University of Stuttgart <br>
 * <br>
 *
 * @author Kalman Kepes - kepeskn@studi.informatik.uni-stuttgart.de
 */
@Component
public class BPELScopeBuilder {

    final static Logger LOG = LoggerFactory.getLogger(BPELScopeBuilder.class);

    private final PluginRegistry pluginRegistry;

    @Inject
    public BPELScopeBuilder(PluginRegistry pluginRegistry) {
        this.pluginRegistry = pluginRegistry;
    }

    /**
     * <p>
     * Filters IA and DA Candidates inside the given ProvisioningChain. Filtering means if there are IA and DACandidates
     * which don't operate on the same Template Implementation they are deleted.
     * </p>
     *
     * @param chain a ProvisioningChain to filter
     */
    private void filterIncompatibleIADACandidates(final OperationChain chain) {
        final Map<IANodeTypeImplCandidate, DANodeTypeImplCandidate> compatibleCandidates = new HashMap<>();
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            for (final DANodeTypeImplCandidate daCandidate : chain.daCandidates) {
                if (iaCandidate.nodeImpl.getName().equals(daCandidate.impl.getName())) {
                    compatibleCandidates.put(iaCandidate, daCandidate);
                }
            }
        }
        chain.daCandidates = new ArrayList<>();
        chain.iaCandidates = new ArrayList<>();

        for (final IANodeTypeImplCandidate key : compatibleCandidates.keySet()) {
            chain.iaCandidates.add(key);
            chain.daCandidates.add(compatibleCandidates.get(key));
        }
    }

    /**
     * Creates a ProvisioningChain for the given RelationshipTemplate.
     *
     * @param relationshipTemplate an AbstractRelationshipTemplate which should be provisioned
     * @param forSource            determines whether provisioning is handle on the SourceInterface (set to true) or
     *                             TargetInterface
     * @return a ProvisioningChain with complete provisioning Candidates
     */
    public OperationChain createOperationChain(final AbstractRelationshipTemplate relationshipTemplate,
                                               final boolean forSource) {
        // get implementations
        final List<AbstractRelationshipTypeImplementation> relationshipTypeImpls =
            relationshipTemplate.getImplementations();

        if (relationshipTypeImpls.isEmpty()) {
            return null;
        }

        // init chain
        final OperationChain chain = new OperationChain(relationshipTemplate);

        // calculate infraNodes
        final List<AbstractNodeTemplate> infraNodes = new ArrayList<>();

        ModelUtils.getInfrastructureNodes(relationshipTemplate, infraNodes, forSource);

        // check for IA Plugins
        final List<IPlanBuilderPrePhaseIAPlugin<?>> iaPlugins = pluginRegistry.getIaPlugins();

        calculateBestImplementationRelationIACandidates(relationshipTypeImpls, iaPlugins, infraNodes,
            chain, forSource);

        // check for prov plugins
        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins =
            pluginRegistry.getProvPlugins();

        calculateProvPlugins(chain, provPlugins);

        filterIADACandidatesRelations(chain);

        reorderProvCandidates(chain);

        return chain;
    }

    /**
     * TODO: We assume that IAs are already provisinoned on IA engine
     *
     * @param relationshipTemplate
     * @param interfaceName
     * @param operationName
     * @return OperationChain
     */
    public OperationChain createOperationCall(final AbstractRelationshipTemplate relationshipTemplate,
                                              final String interfaceName, final String operationName) {

        final List<AbstractRelationshipTypeImplementation> impls = relationshipTemplate.getImplementations();
        if (impls.isEmpty()) {
            LOG.warn("No implementations available for RelationshipTemplate {} , can't generate Provisioning logic",
                relationshipTemplate.getId());
            return null;
        }

        final OperationChain chain = new OperationChain(relationshipTemplate);
        chain.provCandidates = new ArrayList<>();

        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins =
            pluginRegistry.getProvPlugins();

        for (final AbstractRelationshipTypeImplementation impl : impls) {
            final OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                for (final IPlanBuilderProvPhaseOperationPlugin<?> plugin : provPlugins) {
                    if (plugin.canHandle(ia.getArtifactType())
                        && getOperationForIa(chain.relationshipTemplate, ia, operationName) != null) {
                        provCandidate.add(getOperationForIa(chain.relationshipTemplate, ia,
                            operationName),
                            ia, plugin);
                    }
                }
            }
            chain.provCandidates.add(provCandidate);
        }
        return chain;
    }

    /**
     * Creates a complete ProvisioningChain for the given NodeTemplate
     *
     * @param nodeTemplate an AbstractNodeTemplate to create a ProvisioningChain for
     * @return a complete ProvisioningChain
     */
    public OperationChain createOperationCall(final AbstractNodeTemplate nodeTemplate,
                                              final String interfaceName, final String operationName) {
        // get nodetype implementations
        final List<AbstractNodeTypeImplementation> nodeTypeImpls = nodeTemplate.getImplementations();

        if (nodeTypeImpls.isEmpty()) {
            LOG.warn("No implementations available for NodeTemplate {} , can't generate Provisioning logic",
                nodeTemplate.getId());
            return null;
        }

        final OperationChain chain = new OperationChain(nodeTemplate);

        // calculate infrastructure nodes
        final List<AbstractNodeTemplate> infraNodes = new ArrayList<>();
        ModelUtils.getInfrastructureNodes(nodeTemplate, infraNodes);

        // we'll add here a dummy infra node, representing the management
        // infrastructure of the tosca engine (WAR IA's implementing tosca
        // operation,..)
        infraNodes.add(new TOSCAManagementInfrastructureNodeTemplate());

        // check for IA Plugins
        final List<IPlanBuilderPrePhaseIAPlugin<?>> iaPlugins = pluginRegistry.getIaPlugins();

        LOG.debug("Calculating best IA candidates for nodeTemplate {} ", nodeTemplate.getId());
        // calculate nodeImpl candidates where all IAs of each can be
        // provisioned
        calculateBestImplementationIACandidates(nodeTypeImpls, iaPlugins, infraNodes, chain,
            interfaceName, operationName);
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            final int length = iaCandidate.ias.size();
            for (int i = 0; i < length; i++) {
                final AbstractImplementationArtifact ia = iaCandidate.ias.get(i);
                final AbstractNodeTemplate infraNode = iaCandidate.infraNodes.get(i);
                final IPlanBuilderPlugin plugin = iaCandidate.plugins.get(i);
                LOG.debug("Found IA {} for deployment on the InfraNode {} with the Plugin {}",
                    ia.getName(), infraNode.getId(), plugin.getID());
            }
        }

        // check for prov plugins
        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins =
            pluginRegistry.getProvPlugins();

        // search for prov plugins according to the chosen IA provisionings in
        // the chain
        calculateProvPlugins(chain, provPlugins, interfaceName, operationName);

        // filter ia and da candidates where the operations can't be executed
        filterIADACandidates(chain);

        // order provisioning candidates
        reorderProvCandidates(chain);

        // TODO consistency plugins
        final List<String> array = new ArrayList<>();

        array.add(operationName);
        // select provisioning
        selectProvisioning(chain, array);

        return chain;
    }

    /**
     * Creates a complete ProvisioningChain for the given NodeTemplate
     *
     * @param nodeTemplate an AbstractNodeTemplate to create a ProvisioningChain for
     * @return a complete ProvisioningChain
     */
    public OperationChain createOperationChain(final AbstractNodeTemplate nodeTemplate, final List<String> operationNames) {
        // get nodetype implementations
        final List<AbstractNodeTypeImplementation> nodeTypeImpls = nodeTemplate.getImplementations();

        if (nodeTypeImpls.isEmpty()) {
            LOG.warn("No implementations available for NodeTemplate {} , can't generate Provisioning logic",
                nodeTemplate.getId());
            return null;
        }

        final OperationChain chain = new OperationChain(nodeTemplate);

        // calculate infrastructure nodes
        final List<AbstractNodeTemplate> infraNodes = new ArrayList<>();
        ModelUtils.getInfrastructureNodes(nodeTemplate, infraNodes);

        // we'll add here a dummy infra node, representing the management
        // infrastructure of the tosca engine (WAR IA's implementing tosca
        // operation,..)
        infraNodes.add(new TOSCAManagementInfrastructureNodeTemplate());

        // check for IA Plugins
        final List<IPlanBuilderPrePhaseIAPlugin<?>> iaPlugins = pluginRegistry.getIaPlugins();

        LOG.debug("Calculating best IA candidates for nodeTemplate {} ", nodeTemplate.getId());
        // calculate nodeImpl candidates where all IAs of each can be
        // provisioned
        calculateBestImplementationIACandidates(nodeTypeImpls, iaPlugins, infraNodes, chain);
        for (final IANodeTypeImplCandidate wrapper : chain.iaCandidates) {
            final int length = wrapper.ias.size();
            for (int i = 0; i < length; i++) {
                final AbstractImplementationArtifact ia = wrapper.ias.get(i);
                final AbstractNodeTemplate infraNode = wrapper.infraNodes.get(i);
                final IPlanBuilderPlugin plugin = wrapper.plugins.get(i);
                LOG.debug("Found IA {} for deployment on the InfraNode {} with the Plugin {}",
                    ia.getName(), infraNode.getId(), plugin.getID());
            }
        }

        // check for DA Plugins
        final List<IPlanBuilderPrePhaseDAPlugin<?>> daPlugins = pluginRegistry.getDaPlugins();

        // calculate nodeImpl candidates where all DAs of each can be
        // provisioned
        calculateBestImplementationDACandidates(nodeTemplate, nodeTypeImpls, daPlugins, infraNodes,
            chain);
        for (final DANodeTypeImplCandidate wrapper : chain.daCandidates) {
            final int length = wrapper.das.size();
            for (int i = 0; i < length; i++) {
                final AbstractDeploymentArtifact da = wrapper.das.get(i);
                final AbstractNodeTemplate infraNode = wrapper.infraNodes.get(i);
                final IPlanBuilderPlugin plugin = wrapper.plugins.get(i);
                LOG.debug("Found DA {} for deployment on the InfraNode {} with the Plugin {}",
                    da.getName(), infraNode.getId(), plugin.getID());
            }
        }

        // filter for nodeTypeImpl Candidates where both DAs and IAs can
        // be provisioned
        filterIncompatibleIADACandidates(chain);

        // check for prov plugins
        final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins =
            pluginRegistry.getProvPlugins();

        // search for prov plugins according to the chosen IA provisionings in
        // the chain
        calculateProvPlugins(chain, provPlugins);

        // filter ia and da candidates where the operations can't be executed
        filterIADACandidates(chain);

        // order provisioning candidates
        reorderProvCandidates(chain);

        // TODO consistency plugins

        // select provisioning
        selectProvisioning(chain, operationNames);

        return chain;
    }

    /**
     * Reorders the IA/ProvCandidates inside the given ProvisioningChain, so that a correct order is enforced
     *
     * @param chain a ProvisioningChain
     */
    private void reorderProvCandidates(final OperationChain chain) {
        // ia candidates and da candidates in the chains are already ordered
        // accordingly
        final List<OperationNodeTypeImplCandidate> reorderedList = new ArrayList<>();
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            final int iaCandidateSize = iaCandidate.ias.size();
            for (final OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
                for (final AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
                    for (final AbstractImplementationArtifact provCandidateIa : provCandidate.ias) {
                        if (iaCandidateIa.equals(provCandidateIa)) {
                            reorderedList.add(provCandidate);
                            break;
                        }
                    }
                }
            }
        }

        chain.provCandidates = reorderedList;
    }

    /**
     * Filters IA and ProvCandidates which aren't generated from the same Template Implementation
     *
     * @param chain a ProvisioningChain
     */
    private void filterIADACandidatesRelations(final OperationChain chain) {
        if (chain.provCandidates.size() != chain.iaCandidates.size()) {
            final List<IANodeTypeImplCandidate> iaCandidatesToRemove = new ArrayList<>();
            final Set<OperationNodeTypeImplCandidate> provCandidatesWithMatch = new HashSet<>();
            for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
                final int iaCandidateSize = iaCandidate.ias.size();
                OperationNodeTypeImplCandidate match = null;
                for (final OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
                    int count = 0;
                    for (final AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
                        for (final AbstractImplementationArtifact procCandidateIa : provCandidate.ias) {
                            if (iaCandidateIa.equals(procCandidateIa)) {
                                count++;
                            }
                        }
                    }
                    if (count == iaCandidateSize) {
                        match = provCandidate;
                    }
                }
                if (match == null && !chain.provCandidates.isEmpty()) {
                    iaCandidatesToRemove.add(iaCandidate);
                } else {
                    if (match != null) {
                        provCandidatesWithMatch.add(match);
                    }
                }
            }
            if (!iaCandidatesToRemove.isEmpty()) {
                // we need to remove ia and da candidates accordingly, because
                // we didn't found matchin operation candidates for them
                for (final IANodeTypeImplCandidate iaCandidateToRemove : iaCandidatesToRemove) {
                    final int index = chain.iaCandidates.indexOf(iaCandidateToRemove);
                    chain.iaCandidates.remove(index);
                }
            }

            if (!provCandidatesWithMatch.isEmpty()) {
                // remove all prov candidates which weren't matched to some ia
                // candidate
                chain.provCandidates = new ArrayList<>();
                for (final OperationNodeTypeImplCandidate matchedCandidate : provCandidatesWithMatch) {
                    chain.provCandidates.add(matchedCandidate);
                }
            }
        }
    }

    /**
     * Filters DA/IA Candidates where no OperationCandidates could be found
     *
     * @param chain a ProvisioningChain
     */
    private void filterIADACandidates(final OperationChain chain) {
        if (chain.provCandidates.size() != chain.iaCandidates.size()) {
            // search for ia/da-Candidates where no operation candidate could be
            // found
            final List<IANodeTypeImplCandidate> iaCandidatesToRemove = new ArrayList<>();
            final Set<OperationNodeTypeImplCandidate> provCandidatesWithMatch = new HashSet<>();
            for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
                final int iaCandidateSize = iaCandidate.ias.size();
                OperationNodeTypeImplCandidate match = null;
                for (final OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
                    int count = 0;
                    for (final AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
                        for (final AbstractImplementationArtifact provCandidateIa : provCandidate.ias) {
                            if (iaCandidateIa.equals(provCandidateIa)) {
                                count++;
                            }
                        }
                    }
                    if (count == iaCandidateSize) {
                        match = provCandidate;
                    }
                }
                if (match == null && !chain.provCandidates.isEmpty()) {
                    iaCandidatesToRemove.add(iaCandidate);
                } else {
                    if (match != null) {
                        provCandidatesWithMatch.add(match);
                    }
                }
            }

            if (!iaCandidatesToRemove.isEmpty()) {
                // we need to remove ia and da candidates accordingly, because
                // we didn't found matchin operation candidates for them
                for (final IANodeTypeImplCandidate iaCandidateToRemove : iaCandidatesToRemove) {
                    final int index = chain.iaCandidates.indexOf(iaCandidateToRemove);
                    chain.iaCandidates.remove(index);
                    chain.daCandidates.remove(index);
                }
            }

            if (!provCandidatesWithMatch.isEmpty()) {
                // remove all prov candidates which weren't matched to some ia
                // candidate
                chain.provCandidates = new ArrayList<>();
                for (final OperationNodeTypeImplCandidate matchedCandidate : provCandidatesWithMatch) {
                    chain.provCandidates.add(matchedCandidate);
                }
            }
        }
    }

    private void selectProvisioning(final OperationChain chain, final List<String> operationNames) {
        // TODO just select the first ia candidate, da candidate and prov candidate for now
        //  Selection should determine a minimal provisioning.
        //  Minimal= min{|IACandidates| + |DACandidates| + |ProvPhaseOperations|}

        // select first candidate set where the provisioning candidate uses the given operations

        int selectedCandidateSet = -1;
        for (int i = 0; i < chain.provCandidates.size(); i++) {

            for (final AbstractOperation op : chain.provCandidates.get(i).ops) {
                if (operationNames.contains(op.getName())) {
                    selectedCandidateSet = i;
                    break;
                }
            }
            if (selectedCandidateSet != -1) {
                break;
            }
        }

        if (selectedCandidateSet != -1) {
            chain.selectedCandidateSet = selectedCandidateSet;
        }
    }

    /**
     * Calculates which Provisioning can be used for Provisioining according to the given IA/DACandidates inside the
     * given ProvisioningChain
     *
     * @param chain       a ProvisioningChain with set DA/IACandidates
     * @param provPlugins a List of ProvPhaseOperationPlugins
     */
    private void calculateProvPlugins(final OperationChain chain,
                                      final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins,
                                      final String interfaceName, final String operationName) {
        final List<OperationNodeTypeImplCandidate> candidates = new ArrayList<>();
        for (final IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
            final OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
            for (final AbstractImplementationArtifact ia : iaCandidate.ias) {
                if (!ia.getInterfaceName().trim().equals(interfaceName.trim())) {
                    continue;
                }
                if (ia.getOperationName() != null && !ia.getOperationName().trim().equals(operationName.trim())) {
                    continue;
                }
                for (final IPlanBuilderProvPhaseOperationPlugin<?> plugin : provPlugins) {
                    if (chain.nodeTemplate != null) {
                        if (plugin.canHandle(ia.getArtifactType())
                            && getOperationForIa(chain.nodeTemplate, ia) != null) {

                            provCandidate.add(getOperationForIa(chain.nodeTemplate, ia), ia, plugin);
                        }
                    } else {
                        if (plugin.canHandle(ia.getArtifactType())
                            && getOperationForIa(chain.relationshipTemplate, ia) != null) {
                            provCandidate.add(getOperationForIa(chain.relationshipTemplate, ia), ia,
                                plugin);
                        }
                    }
                }
            }
            if (chain.nodeTemplate != null) {
                if (provCandidate.isValid(chain.nodeTemplate, interfaceName, operationName)) {
                    candidates.add(provCandidate);
                }
            } else {
                if (provCandidate.isValid(chain.relationshipTemplate)) {
                    candidates.add(provCandidate);
                }
            }
        }
        chain.provCandidates = candidates;
    }

    /**
     * Calculates which Provisioning can be used for Provisioining according to the given IA/DACandidates inside the
     * given ProvisioningChain
     *
     * @param chain       a ProvisioningChain with set DA/IACandidates
     * @param provPlugins a List of ProvPhaseOperationPlugins
     */
    private void calculateProvPlugins(final OperationChain chain,
                                      final List<IPlanBuilderProvPhaseOperationPlugin<?>> provPlugins) {
        final List<OperationNodeTypeImplCandidate> candidates = new ArrayList<>();
        for (final IANodeTypeImplCandidate candidate : chain.iaCandidates) {
            final OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
            for (final AbstractImplementationArtifact ia : candidate.ias) {
                for (final IPlanBuilderProvPhaseOperationPlugin plugin : provPlugins) {
                    if (chain.nodeTemplate != null) {
                        if (plugin.canHandle(ia.getArtifactType())
                            && getOperationForIa(chain.nodeTemplate, ia) != null) {

                            provCandidate.add(getOperationForIa(chain.nodeTemplate, ia), ia, plugin);
                        }
                    } else {
                        if (plugin.canHandle(ia.getArtifactType())
                            && getOperationForIa(chain.relationshipTemplate, ia) != null) {
                            provCandidate.add(getOperationForIa(chain.relationshipTemplate, ia), ia,
                                plugin);
                        }
                    }
                }
            }
            if (chain.nodeTemplate != null) {
                if (provCandidate.isValid(chain.nodeTemplate)) {
                    candidates.add(provCandidate);
                }
            } else {
                if (provCandidate.isValid(chain.relationshipTemplate)) {
                    candidates.add(provCandidate);
                }
            }
        }
        chain.provCandidates = candidates;
    }

    /**
     * Returns the Operation which is implemented by the given IA
     *
     * @param nodeTemplate an AbstractNodeTemplate
     * @param ia           an AbstractImplementationArtifact
     * @return AbstractOperation of the NodeTemplate if the given IA implements it, else null
     */
    private AbstractOperation getOperationForIa(final AbstractNodeTemplate nodeTemplate,
                                                final AbstractImplementationArtifact ia) {

        if (ia.getInterfaceName() != null & ia.getOperationName() == null) {
            return new InterfaceDummy(nodeTemplate, ia);
        }

        for (final AbstractInterface iface : nodeTemplate.getType().getInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(ia.getOperationName())) {
                    return op;
                }
            }
        }
        return null;
    }

    /**
     * Returns the Operation which is implemented by the given IA
     *
     * @param relationshipTemplate an AbstractRelationshipTemplate
     * @param ia                   an AbstractImplementationArtifact
     * @return AbstractOperation of the RelationshipTemplate if the given IA implements it, else null
     */
    private AbstractOperation getOperationForIa(final AbstractRelationshipTemplate relationshipTemplate,
                                                final AbstractImplementationArtifact ia) {
        return getOperationForIa(relationshipTemplate, ia, ia.getOperationName());
    }

    private AbstractOperation getOperationForIa(final AbstractRelationshipTemplate relationshipTemplate,
                                                final AbstractImplementationArtifact ia,
                                                final String operationNameFallback) {
        String name = ia.getOperationName();
        if (name == null) {
            name = operationNameFallback;
        }

        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getSourceInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(name)) {
                    return op;
                }
            }
        }
        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getTargetInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(name)) {
                    return op;
                }
            }
        }
        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getInterfaces()) {
            for (final AbstractOperation op : iface.getOperations()) {
                if (op.getName().equals(name)) {
                    return op;
                }
            }
        }
        return null;
    }

    /**
     * Calculates correct mappings of the given NodeTypeImplementations, PrePhaseDAPlugins and InfrastructureNodes for
     * the given ProvisioningChain
     *
     * @param impls      a List of NodeTypeImplementations
     * @param plugins    a List of PrePhaseDAPlugins
     * @param infraNodes a List of InfrastructureNode of the NodeTemplate the NodeTypeImplementations belong to
     * @param chain      a ProvisioningChain where the candidates are added to
     */
    private void calculateBestImplementationDACandidates(final AbstractNodeTemplate nodeTemplate,
                                                         final List<AbstractNodeTypeImplementation> impls,
                                                         final List<IPlanBuilderPrePhaseDAPlugin<?>> plugins,
                                                         final List<AbstractNodeTemplate> infraNodes,
                                                         final OperationChain chain) {
        final List<DANodeTypeImplCandidate> candidates = new ArrayList<>();

        for (final AbstractNodeTypeImplementation impl : impls) {
            LOG.debug("Checking DAs of NodeTypeImpl {} and NodeTemplate {}", impl.getName(),
                nodeTemplate.getId());
            final DANodeTypeImplCandidate candidate = new DANodeTypeImplCandidate(nodeTemplate, impl);

            final List<AbstractDeploymentArtifact> effectiveDAs =
                calculateEffectiveDAs(nodeTemplate, impl);

            for (final AbstractDeploymentArtifact da : effectiveDAs) {
                LOG.debug("Checking whether DA {} can be deployed", da.getName());
                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    LOG.debug("Checking if DA {} can be deployed on InfraNode {}", da.getName(),
                        infraNode.getId());
                    for (final IPlanBuilderPrePhaseDAPlugin plugin : plugins) {
                        LOG.debug("Checking with Plugin {}", plugin.getID());
                        if (plugin.canHandle(da, infraNode.getType())) {
                            LOG.debug("Adding Plugin, can handle DA on InfraNode");
                            candidate.add(da, infraNode, plugin);
                        }
                    }
                }
            }
            if (candidate.isValid()) {
                LOG.debug("Generated Candidate was valid, adding to all Candidates");
                candidates.add(candidate);
            } else {
                LOG.debug("Generated Candidate was invalid, don't add to all Candidates");
            }
        }
        chain.daCandidates = candidates;
    }

    /**
     * Searches for NodeTypeImplementations where all IA's can be provisioned by some plugin in the system.
     *
     * @param impls      all implementations of single nodetype
     * @param plugins    all plugins possibly capable of working with the ia's contained in a nodetypeImplementation
     * @param infraNodes all infrastructure nodes of the nodetemplate the nodetypeimplementations originate from
     * @return a list of Wrapper class Object which contain information of which ia is provisioned on which
     * infrastructure by which plugin
     */
    private void calculateBestImplementationIACandidates(final List<AbstractNodeTypeImplementation> impls,
                                                         final List<IPlanBuilderPrePhaseIAPlugin<?>> plugins,
                                                         final List<AbstractNodeTemplate> infraNodes,
                                                         final OperationChain chain, final String interfaceName,
                                                         final String operationName) {

        final List<IANodeTypeImplCandidate> candidates = new ArrayList<>();
        // cycle through all implementations
        for (final AbstractNodeTypeImplementation impl : impls) {
            final IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
            // match the ias of the implementation with the infrastructure nodes
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                if (!ia.getInterfaceName().trim().equals(interfaceName.trim())) {
                    continue;
                }
                if (ia.getOperationName() != null && !ia.getOperationName().trim().equals(operationName.trim())) {
                    continue;
                }

                LOG.debug("Checking whether IA {} can be deployed on a specific Infrastructure Node",
                    ia.getName());
                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    // check if any plugin can handle installing the ia on the
                    // infraNode
                    for (final IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
                        if (plugin.canHandle(ia, infraNode.getType())) {
                            candidate.add(ia, infraNode, plugin);
                        }
                    }
                }
            }
            // check if all ias of the implementation can be provisioned
            if (candidate.isValid(interfaceName, operationName)) {
                candidates.add(candidate);
                LOG.debug("IA Candidate is valid, adding to candidate list");
            } else {
                LOG.debug("IA Candidate is invalid, discarding candidate");
            }
        }
        chain.iaCandidates = candidates;
    }

    /**
     * Searches for NodeTypeImplementations where all IA's can be provisioned by some plugin in the system.
     *
     * @param impls      all implementations of single nodetype
     * @param plugins    all plugins possibly capable of working with the ia's contained in a nodetypeImplementation
     * @param infraNodes all infrastructure nodes of the nodetemplate the nodetypeimplementations originate from
     * @return a list of Wrapper class Object which contain information of which ia is provisioned on which
     * infrastructure by which plugin
     */
    private void calculateBestImplementationIACandidates(final List<AbstractNodeTypeImplementation> impls,
                                                         final List<IPlanBuilderPrePhaseIAPlugin<?>> plugins,
                                                         final List<AbstractNodeTemplate> infraNodes,
                                                         final OperationChain chain) {

        final List<IANodeTypeImplCandidate> candidates = new ArrayList<>();
        // cycle through all implementations
        for (final AbstractNodeTypeImplementation impl : impls) {
            final IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
            // match the ias of the implementation with the infrastructure nodes
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                LOG.debug("Checking whether IA {} can be deployed on a specific Infrastructure Node",
                    ia.getName());
                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    // check if any plugin can handle installing the ia on the
                    // infraNode
                    for (final IPlanBuilderPrePhaseIAPlugin<?> plugin : plugins) {
                        if (plugin.canHandle(ia, infraNode.getType())) {
                            candidate.add(ia, infraNode, plugin);
                        }
                    }
                }
            }
            // check if all ias of the implementation can be provisioned
            if (candidate.isValid()) {
                candidates.add(candidate);
                LOG.debug("IA Candidate is valid, adding to candidate list");
            } else {
                LOG.debug("IA Candidate is invalid, discarding candidate");
            }
        }
        chain.iaCandidates = candidates;
    }

    /**
     * Checks whether the IA implements a SourceInterfaceOperation
     *
     * @param ia                   the IA to check with
     * @param relationshipTemplate the RelationshipTemplate to check with
     * @return true if the IA implements a Operation inside a SourceInterface of the RelationshipTemplate
     */
    private boolean checkIfIaImplementsSrcIface(final AbstractImplementationArtifact ia,
                                                final AbstractRelationshipTemplate relationshipTemplate) {

        for (final AbstractInterface iface : relationshipTemplate.getRelationshipType().getSourceInterfaces()) {
            if (iface.getName().equals(ia.getInterfaceName())) {
                for (final AbstractOperation op : iface.getOperations()) {
                    if (op.getName().equals(ia.getOperationName())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Calculates correct mappings for the given RelationshipTypeImplementations with the given Plugins and InfraNodes
     *
     * @param impls      a List of RelationshipTypeImplementation
     * @param plugins    a List of PrePhaseIAPlugins
     * @param infraNodes a List of InfrastructureNodes which belong to the RelationshipTemplate the given Implementation
     *                   belong to
     * @param chain      a ProvisioningChain to save the results
     * @param forSource  whether the calculation is done for the SourceInterface or for the TargetInterface
     */
    private void calculateBestImplementationRelationIACandidates(final List<AbstractRelationshipTypeImplementation> impls,
                                                                 final List<IPlanBuilderPrePhaseIAPlugin<?>> plugins,
                                                                 final List<AbstractNodeTemplate> infraNodes,
                                                                 final OperationChain chain,
                                                                 final boolean forSource) {
        final List<IANodeTypeImplCandidate> candidates = new ArrayList<>();
        for (final AbstractRelationshipTypeImplementation impl : impls) {
            final IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
            for (final AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
                if (forSource) {
                    // check if ia implements source interfaces
                    if (!checkIfIaImplementsSrcIface(ia, chain.relationshipTemplate)) {
                        continue;
                    }
                } else {
                    if (checkIfIaImplementsSrcIface(ia, chain.relationshipTemplate)) {
                        continue;
                    }
                }

                for (final AbstractNodeTemplate infraNode : infraNodes) {
                    for (final IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
                        if (plugin.canHandle(ia, infraNode.getType())) {
                            candidate.add(ia, infraNode, plugin);
                        }
                    }
                }
            }
            if (candidate.isValid()) {
                candidates.add(candidate);
            }
        }
        chain.iaCandidates = candidates;
    }

    /**
     * Calculates a list of DA's containing an effective set of DA combining the DA's from the given NodeImplementation
     * and NodeTemplates according to the TOSCA specification.
     *
     * @param nodeTemplate the NodeTemplate the NodeImplementations belongs to
     * @param nodeImpl     a NodeTypeImplementation for the given NodeTemplate
     * @return a possibly empty list of AbstractDeploymentArtifacts
     */
    static List<AbstractDeploymentArtifact> calculateEffectiveDAs(final AbstractNodeTemplate nodeTemplate,
                                                                  final AbstractNodeTypeImplementation nodeImpl) {
        final List<AbstractDeploymentArtifact> effectiveDAs = new ArrayList<>();

        final List<AbstractDeploymentArtifact> nodeImplDAs = nodeImpl.getDeploymentArtifacts();
        final List<AbstractDeploymentArtifact> nodeTemplateDAs = nodeTemplate.getDeploymentArtifacts();

        for (final AbstractDeploymentArtifact templateDa : nodeTemplateDAs) {
            boolean overridesDA = false;
            int daIndex = -1;
            for (int i = 0; i < nodeImplDAs.size(); i++) {
                final AbstractDeploymentArtifact nodeImplDa = nodeImplDAs.get(i);

                if (nodeImplDa.getName().equals(templateDa.getName())
                    & nodeImplDa.getArtifactType().equals(nodeImplDa.getArtifactType())) {
                    overridesDA = true;
                    daIndex = i;
                }
            }

            if (overridesDA) {
                nodeImplDAs.remove(daIndex);
            }
        }

        effectiveDAs.addAll(nodeTemplateDAs);
        effectiveDAs.addAll(nodeImplDAs);

        return effectiveDAs;
    }
}
